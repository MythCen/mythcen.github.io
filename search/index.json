[{"content":"首先，需要明确我们的目的——单元测试\n单元测试（Unit Tesing）是针对程序的最小部件，检查代码是否会按照预期工作的一种测试手段。在过程式编程中最小就是一个函数，在面向对象编程中最小部件就是对象方法。\n从单元测试开始 相关概念 黑盒测试 黑盒测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息\n白盒测试 白盒测试，又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒指的是盒子是可视的，即清楚盒子内部的东西以及里面是如何运作的。\n动机 验证 设计 文档 回归 单元测试的基本概念 单元测试一般包含以下几个部分：\n被测试的对象是什么 要测试该对象的什么功能 实际得到的结果 期望的结果 mock / spy 具体到某个单元测试，往往包含以下几个步骤：\n准备阶段：构造参数，创建 spy 等 执行阶段：用构造好的参数执行被测试代码 断言阶段：用实际得到的结果与期望的结果比较，以判断该测试是否正常 清理阶段：清理准备阶段对外部环境的影响，移除在准备阶段创建的 spy 等 Jest 为什么选择 jest 单元测试的执行通常需要测试规范、断言、mock、覆盖率工具等支持，上述工具在繁荣的 Node.js 生态中有很多优秀实现，但组合起来使用会带来两个问题\n多种工具的选择和学习有一定的成本 把多个工具组合成特定测试解决方案的配置复杂 而 Jest 是用来创建、执行和构建测试用例的 JavaScript 测试库，自身包含了 驱动、断言库、mock 、代码覆盖率等多种功能，配置使用相当简单\n安装 配置 基本配置 jest.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 // jest.config.js // Sync object module.exports = { verbose: true, }; // Or async function module.exports = async () =\u0026gt; { return { verbose: true, }; }; jest.config.ts\n需要搭配 ts-node\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // jest.config.ts import type {Config} from \u0026#39;@jest/types\u0026#39;; // Sync object const config: Config.InitialOptions = { verbose: true, }; export default config; // Or async function export default async (): Promise\u0026lt;Config.InitialOptions\u0026gt; =\u0026gt; { return { verbose: true, }; }; Package.json\n1 2 3 4 5 6 { \u0026#34;name\u0026#34;: \u0026#34;my-project\u0026#34;, \u0026#34;jest\u0026#34;: { \u0026#34;verbose\u0026#34;: true } } \u0026ndash;config \u0026lt;path/to/file.js|ts|cjs|mjs|json\u0026gt;\n1 2 3 4 { \u0026#34;bail\u0026#34;: 1, \u0026#34;verbose\u0026#34;: true } 路径配置 Jest 会自动运行 sum.test.js 文件，其默认匹配规则\n匹配 __test__ 文件夹下的 .js 文件（.jsx .ts .tsx 也可以） 匹配所有后缀为 .test.js 或 .spec.js 的文件（.jsx .ts .tsx 也可以） 可以通过根目录下的 jest.config.js 文件自定义测试文件匹配规则\n1 2 3 4 5 6 7 8 9 10 11 // jest.config.js //自定义匹配规则 module.exports = { testMatch: [ // glob 格式 \u0026#34;**/__tests__/**/*.[jt]s?(x)\u0026#34;, \u0026#34;**/?(*.)+(spec|test).[jt]s?(x)\u0026#34; ], // 正则表达式格式，与 testMatch 互斥，不能同时声明 // testRegex: \u0026#39;(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.[jt]sx?$\u0026#39;, }; 转换配置 transform\n转换器是提供同步功能以转换源文件的模块。例如，如果希望能够在node尚不支持的模块或测试中使用新的语言功能，则可以插入许多将JavaScript的未来版本编译为当前版本的编译器之一\n匹配配置 testRegex\nJest用于检测测试文件的模式。默认情况下，它会查找.js，.jsx，.ts和.tsx里面的文件__tests__夹，以及带有后缀的任何文件.test或.spec\nApi 断言 jest提供了比较丰富的断言，此处介绍一些常用的。\n相等 toBe toEqual not 真值 toBeNull 只匹配 null toBeUndefined 只匹配 undefined toBeDefined 与 toBeUndefined 相反 toBeTruthy 匹配任何 if 语句为真 toBeFalsy 匹配任何 if 语句为假 数字 toBeCloseTo 包含 toContain 异步 callback 默认情况下，Jest 测试一旦执行到末尾就会完成。这意味着，像这样写不会有效果——\n1 2 3 4 5 6 7 test(\u0026#39;the data is peanut butter\u0026#39;, () =\u0026gt; { function callback(data) { expect(data).toBe(\u0026#39;peanut butter\u0026#39;); } fetchData(callback); }); 一旦fetchData执行结束，此测试就在没有调用回调函数前结束.\n解决的方法之一，是使用jest提供的done函数，相当于可以手动标记执行完该函数才意味着执行完毕。\n1 2 3 4 5 6 7 8 9 10 11 12 test(\u0026#39;the data is peanut butter\u0026#39;, done =\u0026gt; { function callback(data) { try { expect(data).toBe(\u0026#39;peanut butter\u0026#39;); done(); } catch (error) { done(error); } } fetchData(callback); }); 若 done() 函数从未被调用，测试用例会如预期的那样执行失败（显示超时错误）。\n若 expect 执行失败，它会抛出一个错误，后面的 done() 不再执行。 而try被用来捕获这个错误。\npromise 使用promise的时候，需要注意返回该promise\n1 2 3 4 test(\u0026#39;the fetch fails with an error\u0026#39;, () =\u0026gt; { expect.assertions(1); return fetchData().catch(e =\u0026gt; expect(e).toMatch(\u0026#39;error\u0026#39;)); }); 此处expect.assertions(2)用来确保异步代码里的断言被执行，从而捕获可能的错误。\n想更进一步的判断的话，可以使用.resolves / .rejects这两个api\n1 2 3 test(\u0026#39;the fetch fails with an error\u0026#39;, () =\u0026gt; { return expect(fetchData()).rejects.toMatch(\u0026#39;error\u0026#39;); }); 或者，可以在测试中使用 async 和 await。\n1 2 3 4 5 6 7 test(\u0026#39;the data is peanut butter\u0026#39;, async () =\u0026gt; { await expect(fetchData()).resolves.toBe(\u0026#39;peanut butter\u0026#39;); }); test(\u0026#39;the fetch fails with an error\u0026#39;, async () =\u0026gt; { await expect(fetchData()).rejects.toThrow(\u0026#39;error\u0026#39;); }); 作用域 `test.only beforeEach 和 afterEach beforeAll 和 afterAll describe jest通过 describe 块来将测试分组，在不同的组里可以指定不同的重复性工作，例如数据初始化、结束后执行的数据清理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Applies to all tests in this file beforeEach(() =\u0026gt; { return initializeCityDatabase(); }); test(\u0026#39;city database has Vienna\u0026#39;, () =\u0026gt; { expect(isCity(\u0026#39;Vienna\u0026#39;)).toBeTruthy(); }); test(\u0026#39;city database has San Juan\u0026#39;, () =\u0026gt; { expect(isCity(\u0026#39;San Juan\u0026#39;)).toBeTruthy(); }); describe(\u0026#39;matching cities to foods\u0026#39;, () =\u0026gt; { // Applies only to tests in this describe block beforeEach(() =\u0026gt; { return initializeFoodDatabase(); }); test(\u0026#39;Vienna \u0026lt;3 sausage\u0026#39;, () =\u0026gt; { expect(isValidCityFoodPair(\u0026#39;Vienna\u0026#39;, \u0026#39;Wiener Schnitzel\u0026#39;)).toBe(true); }); test(\u0026#39;San Juan \u0026lt;3 plantains\u0026#39;, () =\u0026gt; { expect(isValidCityFoodPair(\u0026#39;San Juan\u0026#39;, \u0026#39;Mofongo\u0026#39;)).toBe(true); }); }); Jest 会在所有真正的测试开始之前执行测试文件里所有的 describe 处理程序（handlers）\n当 describe 块运行完后,，默认情况下，Jest 会按照 test 出现的顺序依次运行所有测试,\n注：test也可写作it；test为it的别名，功能是一致的。\nMock Mock函数 fn 使用 jest.fn() 就可以 mock 一个函数，mock 函数有 .mock 属性，标识函数被调用及返回值信息\n在某些情况下，除了指定返回值之外，完全替换模拟函数的实现是有用的\n.mock 所有的 mock 函数都有个特殊的 .mock属性，它保存了关于此函数如何被调用、调用时的返回值的信息。 .mock 属性还追踪每次调用时 this的值，\n这些 mock 成员变量在测试中非常有用，用于说明这些 function 是如何被调用、实例化或返回的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // The function was called exactly once expect(someMockFunction.mock.calls.length).toBe(1); // The first arg of the first call to the function was \u0026#39;first arg\u0026#39; expect(someMockFunction.mock.calls[0][0]).toBe(\u0026#39;first arg\u0026#39;); // The second arg of the first call to the function was \u0026#39;second arg\u0026#39; expect(someMockFunction.mock.calls[0][1]).toBe(\u0026#39;second arg\u0026#39;); // The return value of the first call to the function was \u0026#39;return value\u0026#39; expect(someMockFunction.mock.results[0].value).toBe(\u0026#39;return value\u0026#39;); // This function was instantiated exactly twice expect(someMockFunction.mock.instances.length).toBe(2); // The object returned by the first instantiation of this function // had a `name` property whose value was set to \u0026#39;test\u0026#39; expect(someMockFunction.mock.instances[0].name).toEqual(\u0026#39;test\u0026#39;); mockReturnValueOnce mockReturnValue mock函数的返回值也是可以模拟的\n1 2 3 4 5 6 7 8 9 10 11 12 const filterTestFn = jest.fn(); // Make the mock return `true` for the first call, // and `false` for the second call filterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false); const result = [11, 12].filter(num =\u0026gt; filterTestFn(num)); console.log(result); // \u0026gt; [11] console.log(filterTestFn.mock.calls); // \u0026gt; [ [11], [12] ] 大多数现实世界例子中，实际是在依赖的组件上配一个模拟函数并配置它，但手法是相同的。 在这些情况下，尽量避免在非真正想要进行测试的任何函数内实现逻辑。\nMock模块 mock 使用 jest.mock(模块名) 可以 mock 一个模块，比如某些功能依赖了 axios 发异步请求，在实际测试的时候我们希望直接返回既定结果，不用发请求，就可以 mock axios\nMock实现 mockImplementation 当需要定义从另一个模块创建的模拟函数的默认实现时，mockImplementation方法非常有用\n1 2 3 4 5 6 7 8 9 10 const myMockFn = jest .fn() .mockImplementationOnce(cb =\u0026gt; cb(null, true)) .mockImplementationOnce(cb =\u0026gt; cb(null, false)); myMockFn((err, val) =\u0026gt; console.log(val)); // \u0026gt; true myMockFn((err, val) =\u0026gt; console.log(val)); // \u0026gt; false 快照 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /*快照测试*/ import React from \u0026#39;react\u0026#39;; // import toJson from \u0026#39;enzyme-to-json\u0026#39;; import render from \u0026#39;react-test-renderer\u0026#39;; import ALink from \u0026#39;../Link\u0026#39;; describe(\u0026#39;Link\u0026#39;, () =\u0026gt; { it(\u0026#39;正确的快照\u0026#39;, function () { const tree = render.create(\u0026lt;ALink page=\u0026#34;http://www.facebook.com\u0026#34;\u0026gt;facebook\u0026lt;/ALink\u0026gt;).toJSON(); expect(tree).toMatchSnapshot(); }); it(\u0026#39;这个是正确的快照更改\u0026#39;, function () { const tree = render.create(\u0026lt;ALink page=\u0026#34;http://www.yanleweb.com\u0026#34;\u0026gt;yanlelele\u0026lt;/ALink\u0026gt;).toJSON(); expect(tree).toMatchSnapshot(); }); it(\u0026#39;这种时候，快照就要报错了\u0026#39;, function () { const user = { createAt: new Date(), id: Math.floor(Math.random() * 20), name: \u0026#39;yanle\u0026#39;, }; expect(user).toMatchSnapshot({ createAt: expect.any(Date), id: expect.any(Number), }); }); }); 如果我们希望更新快照： yarn test --updateSnapshot 或者 yarn test -u;\n每次运行的时候， 每一个用例就会如果实现了快照， 就会产生一个快照文件\nJest模拟实践 实际上，我们的单元测试环境并不会那么单纯，不同的环境需要加上不同的配置，甚至需要测试因为环境关联的特有功能。\nJest 与 TypeScript \u0026amp; Babel 要支持typescript \u0026amp; babel的环境，需要以下几个步骤\n安装依赖 1 $ npm i -D @babel/core @babel/preset-env @babel/preset-typescript @types/jest 然后，最好安装用于jest（ts-jest）的TypeScript预处理程序，以使jest可以即时转换TypeScript并内置源映射支持。\n1 $ npm i -D ts-jest 添加babel配置\n1 2 3 4 5 6 7 // babel.config.js module.exports = { presets: [ [\u0026#39;@babel/preset-env\u0026#39;, { targets: { node: \u0026#39;current\u0026#39; } }], \u0026#39;@babel/preset-typescript\u0026#39;, ], }; Jest 与 React React 官方提供了一种方案，用来进行React单元测试——react-test-renderer\u0026amp;react-dom/test-utils\nReact-test-renderer\n在说 react-test-renderer 之前，让我们先聊聊什么是 renderer。React 最早是被用来开发网页的，所以早期的 React 库中还包含了大量和 DOM 相关的逻辑。后来 React 的设计思想慢慢被迁移到其它场景，最被人们熟知的莫过于 React Native 了。为了灵活性和扩展性，React 的代码被分拆为 React 核心代码与各种 renderer。React 自带了 3 个 renderer，前两个是大家常见的：\nreact-dom 负责将组建渲染到浏览器页面中。 react-native-renderer 负责将组件渲染成原生场景中的各种 “View”。 而这里的 react-test-renderer 则负责将组件输出成 JSON 对象以方便我们遍历、断言或是进行 snapshot 测试。\nReact-dom/test-utils\n该库中的方法主要作用是帮我们遍历 ReactDOM 生成的 DOM 树，方便我们编写断言。**注意：使用该库时必须提供一个 DOM 环境。**当然这个 DOM 环境可以是 jsdom 这种模拟环境。(Jest 默认的执行环境就是 jsdom)\n如果需要测试事件（如 click, change, blur 等），那么使用 react-dom/test-utils 其它时候使用更简单、灵活的 react-test-renderer enzyme\n另一种方案，是使用优秀的第三方库——enzyme\nEnzyme 底层其实也是基于 react-test-renderer 和 react-dom/test-utils 的，通过模仿jQuery的DOM操作和遍历的API，Enzyme可以直观且灵活构建单元测试。\n它在二者的基础上进行了封装提供了更加简单易用的查询、断言方法。在概念上，Enzyme 也与二者非常相似。在 Enzyme 中有三种 render 模式：\nShallow Rendering 对应 react-test-renderer/shallow Full DOM Rendering 对应 react-dom/test-utils Static Rendering 对应 react-test-renderer 在使用上的区别，下文会具体介绍。\n最后，综合考虑，还是选用案例更多，更加成熟的enzyme。以下的演示以enzyme为例。\n安装依赖 1 2 $ npm i -S react react-dom $ npm i -D @babel/preset-env @babel/preset-react enzyme enzyme-adapter-react-16 其中，enzyme-adapter-react-16是与react对应的enzyme依赖（依赖详见官方文档）\n最后，需要手动配置一下对应的适配器\n1 2 3 4 import Enzyme from \u0026#39;enzyme\u0026#39;; import Adapter from \u0026#39;enzyme-adapter-react-16\u0026#39;; Enzyme.configure({ adapter: new Adapter() }); enzyme本身是适配不同的测试框架的，如果想要使用带有自定义断言和更方便函数的enzyme，可以安装jest-enzyme\n配置 babel 1 2 3 4 5 6 7 // babel.config.js module.exports = { presets: [ [\u0026#39;@babel/preset-env\u0026#39;, { targets: { node: \u0026#39;current\u0026#39; } }], \u0026#39;@babel/preset-react\u0026#39;, ], }; 使用class的写法还需——\n1 $ npm i -D @babel/plugin-proposal-class-properties 只用React Hook则不用\n使用 shallow\nShallow Rendering（浅渲染）指的是，将一个组件渲染成虚拟DOM对象，但是只渲染第一层，不渲染所有子组件，所以处理速度非常快。它不需要DOM环境，因为根本没有加载进DOM。\nshallow的函数输入组件，返回组件的浅渲染结果，而返回的结果可以用类似jquery的形式获取组件的信息。\nmount\nmount方法用于将React组件加载为真实DOM节点。 然而真实DOM需要一个浏览器环境，为了解决这个问题，我们可以用到jsdom. 下面是jsdom的官方介绍：\njsdom is a pure-JavaScript implementation of many web standards, notably the WHATWG DOM and HTML Standards, for use with Node.js. In general, the goal of the project is to emulate enough of a subset of a web browser to be useful for testing and scraping real-world web applications.\njest自带了jsdom，因此我们不需要去安装了；如果是使用的其他的库，需要手动安装一下。\nrender\nEnzyme还提供了一个不需要jsdom模拟环境解决子组件测试的方法：render。 Enzyme的render函数得到的结果被称为Static Rendered Markup，以下为官方的介绍\nenzyme\u0026rsquo;s render function is used to render react components to static HTML and analyze the resulting HTML structure. render returns a wrapper very similar to the other renderers in enzyme, mount and shallow; however, render uses a third party HTML parsing and traversal library Cheerio. We believe that Cheerio handles parsing and traversing HTML extremely well, and duplicating this functionality ourselves would be a disservice.\n大意是render会根据react组件得到一个静态HTML文本结果，其使用的是cheerio库来解析虚拟DOM。\nrender和mount同样可以测试子组件，那么mount有什么特别之处呢？shallow和mount都是dom对象的缘故，因此他们都是可以模拟交互的，而render 只是html，是不能做到这点的。\n最后需要注意的是，shallow的速度是最快的，render的速度落后于shallow，mount最慢。\n测试用例 组件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import React, { useState } from \u0026#39;react\u0026#39;; export default function CheckboxWithLabel(props) { const [checkStatus, setCheckStatus] = useState(false); const { labelOn, labelOff } = props; function onChange() { setCheckStatus(!checkStatus); } return ( \u0026lt;label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; checked={checkStatus} onChange={onChange} /\u0026gt; {checkStatus ? labelOn : labelOff} \u0026lt;/label\u0026gt; ); } 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import React from \u0026#39;react\u0026#39;; import Enzyme, { shallow } from \u0026#39;enzyme\u0026#39;; import Adapter from \u0026#39;enzyme-adapter-react-16\u0026#39;; import CheckboxWithLabel from \u0026#39;../src/checkbox-with-label\u0026#39;; beforeAll(() =\u0026gt; { // enzyme 初始化 Enzyme.configure({ adapter: new Adapter() }); }) test(\u0026#39;CheckboxWithLabel changes the text after click\u0026#39;, () =\u0026gt; { // 渲染组件 const checkbox = shallow(\u0026lt;CheckboxWithLabel labelOn=\u0026#34;On\u0026#34; labelOff=\u0026#34;Off\u0026#34; /\u0026gt;); expect(checkbox.text()).toEqual(\u0026#39;Off\u0026#39;); // 触发事件 checkbox.find(\u0026#39;input\u0026#39;).simulate(\u0026#39;change\u0026#39;); expect(checkbox.text()).toEqual(\u0026#39;On\u0026#39;); }); 如何编写测试用例 React 组件的单元测试本质是也是单元测试。因此它也符合单元测试的全部特点。唯一不同的地方在于 React 组件的单元测试中我们需要找到合适的方法对执行结果进行断言。换言之，我们要根据 React 的特点来设置代码是否正确执行的判断条件。\n那么 React 组件和其它的被测试对象有何不同呢？仔细想过，我们会发现：\nReact 组件的 render 结果是一个组件树，并且整个树最终会被解析成一个纯粹由 HTML 元素构成的树形结构 React 组件可以拥有 state，且 state 的变化会影响 render 结果 React 组件可以拥有生命周期函数，这些生命周期函数会在特定时间点执行 注意 enzyme在React Hook 中有一些使用限制\nuseEffect()和useLayoutEffect()不会在React浅渲染器中被调用 在React浅渲染器中，useCallback()不记忆回调 当然，也可以不使用\n###Jest 与 Webpack\nJest 可以使用 webpack 来管理资源、 样式和编译的项目。例如图像和字体。\n样式（CSS \u0026amp; CSS Module) 可以使用ES6 Proxy来模拟一个CSS Module：\n安装依赖 1 yarn add --dev identity-obj-proxy 然后在样式对象上，你的所有类别名称查找都会原样返回,例如styles.foobar === 'foobar'\n1 2 3 4 5 6 7 8 9 // package.json (for CSS Modules) { \u0026#34;jest\u0026#34;: { \u0026#34;moduleNameMapper\u0026#34;: { \u0026#34;\\\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$\u0026#34;: \u0026#34;\u0026lt;rootDir\u0026gt;/__mocks__/fileMock.js\u0026#34;, \u0026#34;\\\\.(css|less)$\u0026#34;: \u0026#34;identity-obj-proxy\u0026#34; } } } 如果启用了typescript兼容，除了根据官方案例进行配置以外，还需要在tsconfig.json中将”jsx”选项配置为”react”，否则会报语法无法识别的错误。\n文件 详见Using with webpack · Jest\nJest 与 NextJs NextJs 支持设置用于测试的环境变量\n可以在.env.test 文件里设置测试环境所需的环境变量。与此同时env.test.local是用于本地的，通常需要忽略上传\n如果NODE_ENV被设置为test，则测试环境的变量就会被加载，虽然通常这些都会由测试工具的配置项来配置\nVSCode开发插件 Jest Jest Runner 注意，Jest可以开启两个额外功能\n编辑器里高亮显示测试覆盖到的代码 自动运行 自动运行需要注意一个线程（？）问题，可能会造成卡顿。需要对线程数进行限制\nenzyme Api 下面是Enzyme的一部分API，你可以从中了解它的大概用法。\n.get(index)：返回指定位置的子组件的DOM节点 .at(index)：返回指定位置的子组件 .first()：返回第一个子组件 .last()：返回最后一个子组件 .type()：返回当前组件的类型 .text()：返回当前组件的文本内容 .html()：返回当前组件的HTML代码形式 .props()：返回根组件的所有属性 .prop(key)：返回根组件的指定属性 .state([key])：返回根组件的状态 .setState(nextState)：设置根组件的状态 .setProps(nextProps)：设置根组件的属性 find 关于find方法，有一个注意点，就是它只支持简单选择器，稍微复杂的一点的CSS选择器都不支持。\n1 2 3 4 5 6 component.find(\u0026#39;.my-class\u0026#39;); // by class name component.find(\u0026#39;#my-id\u0026#39;); // by id component.find(\u0026#39;td\u0026#39;); // by tag component.find(\u0026#39;div.custom-class\u0026#39;); // by compound selector component.find(TableRow); // by constructor component.find(\u0026#39;TableRow\u0026#39;); // by display name 快照 react dom交互测试(enzyme)以及快照测试(snapshot) · Issue #265 · frontend9/fe9-library\n回到单元测试 单元测试要做多细？ “I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence (I suspect this level of confidence is high compared to industry standards, but that could just be hubris). If I don’t typically make a kind of mistake (like setting the wrong variables in a constructor), I don’t test for it. I do tend to make sense of test errors, so I’m extra careful when I have logic with complicated conditionals. When coding on a team, I modify my strategy to carefully test code that we, collectively, tend to get wrong.”\n测试越少越好，少到你对你的代码质量达到了某种自信\n我倾向于去对那些有意义的错误做测试，所以，我对一些比较复杂的条件逻辑会异常地小心\n开发过程中，单元测试应该来测试那些可能会出错的地方，或是那些边界情况。\n何时编写单元测试？ 开发过程中，单元测试应该来测试那些可能会出错的地方，或是那些边界情况。\n维护过程中，单元测试应该围绕着 bug 进行，每个 bug 都应该编写响应的单元测试。从而保证同一个 bug 不会出现第二次。\n此外，要为一个被测试对象编写单元测试，那么它应该首先是容易被测试的（这似乎是一句废话）。反过来讲，如果你面对一个函数、类却很难编写测试代码的时候，很可能是你的代码设计上存在问题。比如和外部依赖耦合过于紧密。这种情况下，编写单元测试的过程会倒逼我们优化我们代码的结构。将复杂的代码拆解成为更简单、更容易测试的片段。这个过程本身也会潜移默化的提高我们代码的质量。\n单元测试设计 任何一个单元测试都应该包含：\n正常输入\n离散覆盖参数值域 边界输入\n空值验证 零值验证 最大值验证 非法输入\n入参数据类型非法 内存溢出验证 幂等 对于单元测试来说，保证其幂等性非常重要，幂等就是在相同输入的前提下，其输出结果不随时间而改变。\n所以，我们可以看到，对于函数式编程语言来说，写单元测试则是非常容易的事情，因为在函数式范式中，我们的函数都是纯函数，在范式层面上就已经约束了开发者写出幂等的程序，那么，在javascript领域，我们想要写出质量更高，对测试友好的代码的话，则需要尽可能的写出各种纯函数，从而保证幂等性。\n对于前端而言，其实还包含UI界面的幂等，如何更加高效的保证界面幂等，我们是可以借助jest的快照能力实现html结构级别的幂等验证或者通过gemini的离线截图能力来实现像素级的幂等验证。\nMock Mock数据，在编写单元测试用例的过程中，构造Mock数据是非常重要的实现手段，因为构造数据就是我们在构造输入的过程，比如正常输入/边界输入/非法输入 Mock环境，对于前端自动化测试而言，我们的环境Mock，往往是通过jsdom之类的库实现环境mock，保证离线场景下可以验证依赖浏览器API的程序逻辑 Mock事件，对于离线场景来说人机交互事件是不会有真实人类参与的，所以，我们需要Mock人机交互事件，帮助程序逻辑实现UI界面的交互功能性测试，在React中，是可以通过enzyme来实现Mock事件 Mock模块/第三方包，有些场景我们的程序依赖了某些第三方包，但是第三方包会引入副作用，比如axios，如果被测试的程序使用了该模块，它会走真实的发请求逻辑，这样还需要开一个mock请求服务，如果有一个模块拦截Mock能力，我们就不需要再开一个mock请求服务了，恰好jest提供了模块mock的能力，对于这类问题便可以轻松解决。 Mock函数/类，在Javascript语言中，函数的入参同样也可以是函数(匿名函数)，这恰好是Js最灵活的地方，但是如果参数是函数，则会使得测试用例的编写难度大大提升，我们很难知道入参函数的调用情况，所以，如果我们可以跟踪入参函数调用情况，就能很轻松的验证函数式编程范式下的程序逻辑，恰好jest提供了一个函数Mock能力，可以帮助用户快速Mock一个可以跟踪其调用情况的匿名函数。同样，对于类也是，jest提供了mock类的能力，帮助用户跟踪一个类实例的使用过程。 白盒覆盖 白盒覆盖就是测试用例要尽可能的覆盖程序内部的所有分支语句，从而整体性的保证代码质量。\n我们都知道，覆盖率是衡量单元测试质量的核心指标，但是，对于TDD而言，我们肯定不可能做到一开始就达到100%的覆盖率，所以，正常的单元测试用例，往往是先从黑盒用例来写，也就是程序对外暴露的API层面的测试，前期先将这部分的单测覆盖全，后期，我们在bugfix或者feature addtion的过程中可以逐步增加测试用例，最终逐步达到80%以上的覆盖率即可满足白盒覆盖的效果。\n单测定级 覆盖率是一个非常客观的指标，但是覆盖率对于开发者的认知模型而言是不够清晰结构化的，所以，我们还需要对覆盖率再做一次结构化定级，方便开发者一步步完善单元测试，下面让我们来枚举一下所有的单测级别：1:\nLevel1：正常流程可用，即一个函数在输入正确的参数时，会有正确的输出 Level2：异常流程可抛出逻辑异常，即输入参数有误时，不能抛出系统异常，而是用自己定义的逻辑异常通知上层调用代码其错误之处 Level3：极端情况和边界数据可用，对输入参数的边界情况也要单独测试，确保输出是正确有效的 Level4：所有分支、循环的逻辑走通，不能有任何流程是测试不到的 Level5：输出数据的所有字段验证，对有复杂数据结构的输出，确保每个字段都是正确的 测试用例 有了Jest，我们在写单元测试用例的配置成本已经很低了，所以，单元测试的成本，更多的是编写测试用例上，\n要提高测试用例编写效率，我们主要从几个方向来提高：\n定制标准用例模板，让开发者做填空题，而非选择题 制定单元测试开发规范，帮助开发者写出统一一致的单元测试用例，也方便后续协同开发维护 渐进式编写测试用例，借助bugfix/feature addtion过程逐步完善测试用例，最大化减轻前期时间压力 React组件单测设计 React组件测试用例必须包含\nAPI属性覆盖性测试用例 DOM快照比对，幂等校验 私有Utils函数测试用例。（千万不能忽略Utils函数的测试用例，很多时候，bug就出在这上面） 对DOM结构做用例校验 一个标准的React组件测试用例的输入往往是组件配置或交互事件，输出则是具体的DOM结构，我们的用例校验也都是对DOM结构做用例校验\n从单元测试引申开去 TDD 测试驱动开发，英文为Testing Driven Development，强调的是一种开发方式，以测试来驱动整个项目，即先根据接口完成测试编写，然后在完成功能是要不断通过测试，最终目的是通过所有测试\nBDD 行为驱动开发，英文为Behavior Driven Development，强调的是写测试的风格，即测试要写的像自然语言，让项目的各个成员甚至产品都能看懂测试，甚至编写测试\nTDD和BDD有各自的使用场景，BDD一般偏向于系统功能和业务逻辑的自动化测试设计；而TDD在快速开发并测试功能模块的过程中则更加高效，以快速完成开发为目的\n测试原理 The more your tests resemble the way your software is used, the more confidence they can give you.\nReact本身除了可以使用enzyme，也可以使用官方维护的React Testing Library，原因便是上面这一句。\nReact Testing Library 的测试将与实际的DOM节点一起使用，而不是处理呈现的React组件的实例，可能可以更加精确的贴近真实的使用状况。\n“Most of the damaging features have to do with encouraging testing implementation details. ”，而Enzyme提供了过于齐全的功能，在测试代码里可以访问到真实情况里不可能访问到的实例，可能会让使用者不慎写出错误的测试案例。\n参考 前端单元测试实践 - 知乎](https://zhuanlan.zhihu.com/p/55960017)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2020-12-02T20:00:22+08:00","permalink":"http://mythcen.github.io/p/jest-unit-test/","title":"使用Jest 单元测试"},{"content":"在点击事件冒泡捕获的处理中，通过使用setTimeout 的方式，想要调整某个代码的执行顺序的话，其具体的执行顺序，由一套 机制 去实现，这套机制就是通过定义 宏任务与微任务 来安排执行顺序。\n异步机制：javascript事件循环 概念 内存堆：这是内存分配发生的地方。当V8引擎遇到变量声明和函数声明的时候，就把它们存储在堆里面。\n调用栈：这是你的代码执行时的地方。当引擎遇到像函数调用之类的可执行单元，就会把它们推入调用栈。\nJS单线程，指的是在JS引擎中，解析执行JS代码的调用栈是唯一的，所有的JS代码都在这一个调用栈里按照调用顺序执行，不能同时执行多个函数。\nWeb APIs：还有很多引擎之外的 API，我们把这些称为浏览器提供的 Web API，比如说 事件监听函数、DOM、HTTP／AJAX请求、setTimeout等等。\n回调队列（Event Queue)：按照先进先出的顺序存储所有的回调函数。在任意时间，只要Web API容器中的事件达到触发条件，就可以把回调函数添加到回调队列中去。\n**事件循环 ** (Event Loop)：持续的检测调用栈和回调队列，如果检测到调用栈为空，它就会通知回调队列把队列中的第一个回调函数推入执行栈。\n机制 JS运行时环境的工作机制：\nJS引擎：（唯一主线程）按顺序解析代码，遇到函数声明，入堆，遇到函数调用，入栈； 如果是同步函数调用，直接执行得到结果，同步函数弹出栈，继续下一个函数调用； 如果是异步函数调用，分发给Web API（多个辅助线程），进入Event Table并注册函数，异步函数弹出栈，继续下一个函数调用； Web API中，异步函数在相应辅助线程中处理完成后，即异步函数达到触发条件了，Event Table就将回调函数推入回调队列中。 Event Loop：不停地检查主线程的调用栈与回调队列，当调用栈空时，就把回调队列中的第一个任务推入栈中执行，不断循环。 例子 下面是一段简易的 ajax 请求代码：\n1 2 3 4 5 6 7 8 9 let data = []; $.ajax({ url:www.javascript.com, data:data, success:() =\u0026gt; { console.log(\u0026#39;发送成功!\u0026#39;); } }) console.log(\u0026#39;代码执行结束\u0026#39;); ajax进入Event Table，注册回调函数 success 。\n执行 console.log('代码执行结束') 。\najax事件完成，回调函数 success 进入Event Queue。\n主线程从Event Queue读取回调函数 success 并执行。\n下面是一段更详细的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 setTimeout(function(){ console.log(\u0026#39;Hey, Why am I last?\u0026#39;) }, 0) function sayHi(){ console.log(\u0026#39;Hello\u0026#39;) } function sayBye(){ console.log(\u0026#39;Goodbye\u0026#39;) } sayHi() sayBye() 执行过程是这样的：\nJS引擎会检查整段代码的语法错误，如果没有错误，就从头开始深度解析 首先遇到setTimeout函数调用，把它推入执行栈顶 解析函数体，发现setTimeout函数是Web API的一种，因此就把它分发到Web API模块然后推出栈 因为定时器设置了0ms延迟，因此Web API模块立即把它的匿名回调函数推入到回调函数函数队列。事件循环检测执行栈是否是空闲，但是当前栈并不空闲，因为\u0026hellip; 当setTimeout函数一被分发到Web API模块，JS引擎发现了两个函数声明，把它们存储在堆内存里，然后遇到了sayHi函数的调用，就把它推入了栈顶 sayHi函数调用了console.log函数，因此console.log就被推入了栈顶 JS引擎开始解析console.log的函数体，它接收了一个消息去打印‘Hello’，然后被弹出栈 JS引擎返回到函数sayHi的执行，遇到函数的结束符号}之后，把sayHi弹出栈 sayHi函数一出栈，紧接着sayBye函数被调用，它就被推入栈顶，被解析，调用console.log，把console.log推入栈顶，打印一条消息，弹出栈。然后sayBye函数弹出栈 事件循环检测到执行栈终于空闲了，通知回调队列，然后回调队列把其中的匿名函数推入执行栈 匿名函数（就是setTimeout的回调函数）被解析，调用console.log，console.log推入栈顶 console.log执行完毕、再出栈 匿名函数再被推出栈，程序结束 另一个异步机制：宏任务与微任务 但是，JS异步还有一个机制，就是遇到宏任务，先处理宏任务——将宏任务放入Event Queue，然后再处理微任务——将微任务放入Event Queue。 注意，这里两个Event Queue不是同一个queue。 当js引擎的主线程执行栈为空时，它会优先从微任务queue里遍历注册的回调函数并一一执行，然后再从宏任务的queue里遍历执行注册的回调函数，如下图：\nWeb API中，异步函数在相应辅助线程中处理完成后，即异步函数达到触发条件了（比如setTimeout设置的10s后），如果异步函数是宏任务，则入宏任务消息队列，如果是微任务，则入微任务消息队列；\nEvent Loop不停地检查主线程的调用栈与回调队列，当调用栈空时，就把微任务消息队列中的第一个任务推入栈中执行，执行完成后，再取第二个微任务，直到微任务消息队列为空；然后 去宏任务消息队列中取第一个宏任务推入栈中执行，当该宏任务执行完成后，在下一个宏任务执行前，再依次取出微任务消息队列中的所有微任务入栈执行。\n上述过程不断循环，每当微任务队列清空，可作为本轮事件循环的结束。\n宏任务 (macrotask/task)\n包括：\nI/O（例如点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O） setTimeout setInterval setImmediate（仅Node） requestAnimationFrame（仅浏览器） xhr postMessage MessageChannel 对于 setInterval(fn,ms) 来说，不是每过 ms 秒会执行一次 fn ，而是每过 ms 秒，会有 fn 进入Event Queue。 一旦 setInterval 的回调函数 fn 执行时间超过了延迟时间 ms ，那么就完全看不出来有时间间隔了。\nP.S. 有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了HTML规范文档以后，发现这很显然是和微任务平行的一个操作步骤\nP.S. requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行\n微任务 (microtask/job)\n包括：\nPromise.then catch finally process.nextTick（仅Node） MutationObserver（仅浏览器） P.S. new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。 async/await底层是基于Promise封装的，所以await前面的代码相当于new Promise，是同步进行的，await后面的代码相当于then，才是异步进行的。\nP.S. 在Promise/A+的规范中，Promise的实现可以是微任务，也可以是宏任务，但是普遍的共识表示(至少Chrome是这么做的)，Promise应该是属于微任务阵营的*\n例子 1 2 3 4 5 6 7 8 9 10 setTimeout(_ =\u0026gt; console.log(4)) new Promise(resolve =\u0026gt; { resolve() console.log(1) }).then(_ =\u0026gt; { console.log(3) }) console.log(2) 最终输出结果为：1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4\n再来看一个嵌套的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Promise.resolve().then(()=\u0026gt;{ console.log(\u0026#39;Promise1\u0026#39;) Promise.resolve().then(()=\u0026gt;{ console.log(\u0026#39;Promise2\u0026#39;) }) }) setTimeout(()=\u0026gt;{ console.log(\u0026#39;setTimeout1\u0026#39;) setTimeout(()=\u0026gt;{ console.log(\u0026#39;setTimeout2\u0026#39;) },0) },0) 最后输出结果是Promise1 \u0026gt; setTimeout1 \u0026gt; Promise2 \u0026gt; setTimeout2\nPromise1\nNode 环境 Node中事件循环 Node用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。 Node也是单线程，但是在处理Event Loop上与浏览器稍微有些不同。\n在node里，有一些常用的异步API，这里简单介绍下他们：\nsetImmediate() setImmediate()在一次Event Loop执行完毕后立刻调用。\nsetTimeout则是通过计算一个延迟时间后进行执行。\n所以如下示例，不能保证输出顺序。\n1 2 setTimeout(_ =\u0026gt; console.log(\u0026#39;setTimeout\u0026#39;)) setImmediate(_ =\u0026gt; console.log(\u0026#39;setImmediate\u0026#39;)) 而如果是下面这样，则一定是setImmediate先输出。\n1 2 setTimeout(_ =\u0026gt; console.log(\u0026#39;setTimeout\u0026#39;), 20) setImmediate(_ =\u0026gt; console.log(\u0026#39;setImmediate\u0026#39;)) process.nextTick() process.nextTick()会将回调函数放入队列中,在下一轮Tick时取出执行\n这是因为 ，process.nextTick()中的回调函数执行的优先级要高于setImmediate()。 Node里，事件循环对观察者的检查是有先后顺序的,process.nextTick()属于idle观察者, setImmediate()属于check观察者。\nprocess.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前\u0026quot;执行栈\u0026quot;一次执行完，多个setImmediate可能则需要多次loop才能执行完。 事实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取\u0026quot;事件队列\u0026quot;！\n1 2 3 process.nextTick(function foo() { process.nextTick(foo); }); 参考 https://juejin.im/post/5e972f3c518825739d40874a\nJS核心理论之《运行机制与宏任务、微任务》\nJS核心理论之《JS引擎、运行时与调用椎栈》\n","date":"2020-12-01T20:00:22+08:00","image":"http://mythcen.github.io/p/macrotask-and-microtask/cover_hu3395bef352bdebb2bcd19cd38ef3c08c_281145_120x120_fill_box_smart1_3.png","permalink":"http://mythcen.github.io/p/macrotask-and-microtask/","title":"宏任务与微任务"},{"content":"一个小小的个人空间在互联网上被开辟了。\n最开始是想要有一个总结技术经验，分享自己的编程思考的一个技术博客。\n由于使用过一段时间的Go，本着多了解下后端等其他开发链条的缘故，自己折腾了一个ghost系统，买了腾讯的服务器，最简化搭载nginx和nodeJs，在购买了域名以及备案之后，一个小破站出现了。\n中间折腾了不少，但是最终弄好后，遇到了一个问题——该版本的ghost编辑器会吞掉中文拼音。\n了解到这可能是ghost编辑器对中文的一个bug，虽然发现修改html 的lang属性为cn即可，但是想要修改源码，一是在自己不熟悉的服务器上，二是没有git管理，三是不熟悉ghost系统。再加上工作以及懒，博客的事情就被耽搁下来了，知道服务器一年期到，也没有更新什么文章。\n最后念着初心~~(折腾精神不够)~~，博文本身才是目标，因此选择了方便的静态博客+hugo，重新开始这段旅程。\n本站系技术分享 + 个人博客。\n也许它会成为一座孤岛。\n但它在我心中不会因为无人观赏而失色半分。\n与此同时，它欢迎所有从互联网里，跨洋而来的旅人。\n","date":"2020-11-29T11:05:49+08:00","image":"http://mythcen.github.io/p/start-record/island_huf5a5225bded95e869e8ea621151be2a1_146698_120x120_fill_q75_box_smart1.jpg","permalink":"http://mythcen.github.io/p/start-record/","title":"建站记"}]